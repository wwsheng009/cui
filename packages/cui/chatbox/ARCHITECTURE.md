# Chatbox Component Architecture

## Architecture Design

```
Page (Container)
├── Header (Navigation)
│   ├── Tab Management
│   ├── New Chat Button
│   └── History/Settings Buttons
└── Chatbox (Independent Chat Instance)
    ├── MessageList (Message Display)
    └── InputArea (Input Region)
```

## Core Principles

### 1. Each Tab = An Independent Chatbox Instance

Each tab window has:
- **Independent chat_id**: Generated by frontend (using nanoid)
- **Independent assistant_id**: Each tab can be associated with a different assistant
- **Independent message list**: Stored in `chatStates[chatId]`
- **Independent loading state**: Stored in `loadingStates[chatId]`
- **Independent streaming state**: Stored in `streamingStates[chatId]`
- **Independent abort function**: Stored in `abortHandlesRef.current[chatId]`
- **Independent InputArea**: Each tab's input state is fully managed internally by the component

This ensures:
- When Tab A is streaming, Tab B's input won't show as loading
- Can have conversations in multiple tabs simultaneously (though usually only one streams at a time)
- All related states are cleaned up when a tab is closed

### 2. Assistant Inheritance Rules

When creating a new tab, assistant_id priority:
1. If explicitly specified assistantId → Use the specified one
2. Otherwise inherit from the current active tab's assistantId
3. Finally fall back to the global default assistant

```typescript
// Examples: Creating new tabs
createNewChat() // Inherits assistant from current tab
createNewChat('custom-assistant-id') // Uses specified assistant
```

### 3. State Management

#### Context Level (useChat hook)
Global state managed in the `useChat` hook:

```typescript
// Message state - grouped by chatId
chatStates: Record<string, Message[]>

// Loading/Streaming states - grouped by chatId
loadingStates: Record<string, boolean>
streamingStates: Record<string, boolean>

// Tab list
tabs: ChatTab[]  // { chatId, title, assistantId }

// Currently active tab
activeTabId: string

// Derived states (for the currently active tab)
messages: Message[]           // = chatStates[activeTabId]
loading: boolean             // = loadingStates[activeTabId]
streaming: boolean           // = streamingStates[activeTabId]
```

**Important**: Loading and streaming states are isolated by chatId, ensuring each tab's loading/streaming state is independent and won't affect each other.

#### Component Level
- **InputArea**: Input state is fully managed internally by the component (via `editorRef`)
  - Automatically resets (clears input) when `chatId` changes
  - No need to maintain draft state at the context level
  - This ensures the input is clean when switching tabs

### 4. Component Responsibilities

#### Page Component
- Manages overall layout
- Coordinates Header and Chatbox
- Retrieves state from context and passes to child components

#### Header Component
- Displays and manages tabs
- Provides operations like new chat, history, settings
- Doesn't care about specific chat content

#### Chatbox Component
- Independent chat instance
- Contains MessageList and InputArea
- Receives all necessary props, no need to access context
- Reusable in different scenarios

#### MessageList Component
- Pure presentation component
- Displays message list
- Handles loading state and streaming output

#### InputArea Component
- User input interface
- Supports placeholder and normal modes
- State fully managed internally (via `editorRef`)
- Automatically resets when `chatId` changes, ensuring each tab's input is independent

## Data Flow

### First Use / Empty State Flow
```
User opens app (no tabs)
  → Page renders Chatbox with empty chatId
  → Chatbox shows Placeholder mode (no MessageList, only InputArea)
  → User types and sends message
  → sendMessage auto-creates new tab with unique chatId
  → Tab becomes active, mode switches to normal
```

### Send Message Flow
```
User Input (InputArea) 
  → onSend 
  → Page (from context.sendMessage) 
  → useChat hook
    1. If no activeTabId, auto-create new tab
    2. Add user message to chatStates[activeTabId]
    3. Call API StreamCompletion
    4. Real-time update AI response to chatStates[activeTabId]
  → Chatbox receives updated messages
  → MessageList displays new messages
```

### Switch Tab Flow
```
User clicks Tab (Header)
  → onTabChange
  → activateTab(chatId)
  → setActiveTabId(chatId)
  → Page re-renders with new:
    - messages = chatStates[chatId]
    - assistant = tabs.find(t => t.chatId === chatId).assistantId
  → Chatbox re-renders
    - chatId prop change triggers InputArea's useEffect
    - InputArea automatically clears input (resets state)
  → Display new tab's message list and clean input
```

### New Tab Flow
```
User clicks New Chat (Header)
  → onNewChat
  → createNewChat()
  → useChat hook:
    1. Generate new chatId (nanoid)
    2. Inherit current tab's assistantId (or use default)
    3. Create new tab: { chatId, title: 'New Chat', assistantId }
    4. Initialize empty state: chatStates[chatId] = []
    5. Set as active: setActiveTabId(chatId)
  → Page renders new Chatbox
```

## Advantages

1. **Clear Separation of Concerns**: Each component has a single responsibility, easy to maintain
2. **High Reusability**: Chatbox component can be used in different scenarios
3. **State Isolation**: Each tab's state is completely independent, no interference
4. **Easy to Test**: Simple dependencies between components, convenient for unit testing
5. **Strong Extensibility**: Easy to add new features like history, settings panel, etc.

## Future Extensions

Possible extension points:
- Support Widget mode (embedded chat component)
- Support sidebar history
- Support multi-user collaborative conversations
- Support conversation sharing and export

